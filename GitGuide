= [http://git.or.cz/ Git] Guide =

== Getting Started ==
A quick start guide to using git, especially if you're used to using svn or cvs.

=== Clone the Spacewalk git repository ===
For anonymous access to the Spacewalk source code, feel free to clone the repository:
{{{
git clone git://git.fedorahosted.org/git/spacewalk.git/
}}}

Spacewalk [ContibutorList committers] can clone the repository using the ssh url, which is required if you want to push changes into the repo (and of course you need permission to do so).

{{{
git clone ssh://git.fedorahosted.org/git/spacewalk.git/
}}}

For more details check out the DownloadIt page. 

=== Commit Access ===

If you have been approved to get git commit access to the spacewalk git 
repository you'll need to do the following:

Get your ssh RSA key into the Fedora
accounts system here: (note: use your login name in this url :))

https://admin.fedoraproject.org/accounts/user/edit/USERNAME

And make sure you're a member of:

https://admin.fedoraproject.org/accounts/group/view/gitspacewalk

After that you should be able to git clone with:

{{{
git clone ssh://USERNAME@git.fedorahosted.org/git/spacewalk.git/
}}}

=== Identify Yourself ===
You must configure your name and email address for git to apply it to your commits. There are several ways to do this but one is to do so in {{{~/.gitconfig}}}.

'''NOTE:''' git can differentiate between the author of a commit and person with commit access pushing it to the repository. Most of the time these are the same, but in the case of accepting patches from the community the author should be modified (via setting the {{{GIT_AUTHOR_NAME}}} and {{{GIT_AUTHOR_EMAIL}}} environment variables) while keeping your commit user as yourself.

A good sample ~/.gitconfig:

{{{
[user]
    name = Bill Smith
    email = billsmith@example.com

[alias]
    ci = commit -a
    co = checkout
    st = status -a
    praise = blame 

[apply]
    whitespace = strip

[diff]
    color = auto
    rename = copy 

[pager]
    color = true 

[status]
    color = auto
}}}

== Things To Remember ==

 1. Work in local branches and use master or other tracking branches just for pushing/pulling changes.
 1. Your git commits are local only until you push them to the remote repository. (or submit a patch if you do not have commit access) 
 1. Use rebase to update your local branch before you merge it.
 1. git commands can be run with {{{git-command}}} or {{{git command}}}

== Everyday Workflow ==

Ready to start hacking on the code? Create yourself a branch to work in.
{{{
  git checkout -b mybugfix
}}}
This is actually combining two steps into one, you could also do this the long way with:
{{{
  git branch mybugfix      # create the branch
  git checkout mybugfix    # work on this branch
}}}

The branch will be created from your current location, i.e. if you currently have master checked out your branch will point to the same commit as was the HEAD of master at that time.

List your branches anytime and see which you're working on with:
{{{
  git branch                # list all your branches
}}}
You now have a local branch nobody else can see, they're extremely fast and lightweight, and you can commit as you please. Nothing is pushed to the central repository until you explicitly do so.

Note that the single directory you cloned can be used to work on any branch you like with a simple git checkout command. Switching branches is extremely fast and easy and you can do so at virtually any time. Even if you have changes you don't want to commit (which you often can anyhow as you're working in a private branch), you can use git-stash to stash them away and apply them later, possibly to another branch. (if you found yourself working on the wrong branch)

{{{
  git stash save "Half finished fixes for epoch bug."
}}}

Now that you've branched you can get to work modifying, adding, and deleting files similar to the way you would use svn.

{{{
[gituser@git manager]$ echo "blahblahblah" > newfile
[gituser@git manager]$ git add newfile


[gituser@git manager]$ git-rm Worker.java 
rm 'java/code/src/com/redhat/rhn/manager/Worker.java'
[gituser@git manager]$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       deleted:    Worker.java
#       new file:   newfile
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#       modified:   SatManager.java
#
[gituser@git manager]$
}}}

Now it's time to commit (and you can and should commit often, as often as you like). 

'''IMPORTANT NOTE:''' By default, files you have modified will not be included if you run {{{git commit}}}. Normally you will probably just want to use the -a option to commit all modified files:
{{{
  git commit -a
}}}
If you wish to only include '''some''' of the modified files in your commit, you must do something like:
{{{
  git commit modified-file1.txt  modified-file3.txt
}}}
Repeat for as many commits as you like on your branch until you're satisfied with your bugfix, feature, or whatever.

=== Commit Messages ===

We have a convention for our commits.  The simple rule is:

If you are working on a bugzilla or a feature (that should have a bugzilla associated with it) you should prepend your commit message with the bugzilla # followed by your message describing the commit.

{{{
  BUGZILLA# - comment goes here
}}}

For example: 

{{{
  461162 - just add all the networks to the system profile in cobbler
}}}

If you are not working on a bugzilla in relation to the change just type your message as normal.

=== Pushing Changes ===

NOTE: These instructions apply to those with commit access.

When the time comes to push the changes in your local branch out to the repository, we need to pull down any changes others have pushed since we created that branch and resolve conflicts if necessary. There are two tools to do this, merge and rebase, but for smaller individual changes we will use rebase.

Git rebase essentially checks what commits are in some destination branch that your local branch does not have, what commits are in your local branch that aren't in the destination, then pulls down the new remote commits and re-applies your commits on top of it. It essentially re-does your work again patch by patch, on top of the latest state of the destination branch. (usually master)

To push your fixes in 'mybugfix' out you would do the following:
{{{
  git checkout master           
  git merge mybugfix            # merge in the commits from your local branch (use --squash if you'd like 1 to fold them into one commit)
  git pull --rebase             # pull latest commits down from master, re-apply ours on top
  gitk --all                    # review the status of the repository (can also use "tig" command for this)
  git push origin master        # push commits from local branch master to remote branch with the same name
}}}


=== Submitting Patches ===

For those without commit access, or those who just prefer to submit a patch for review, the steps are as follows:
{{{
  git checkout master                 
  git pull                      # fetch latest remote changes into master (should apply clean)
  git checkout mybugfix        # return to your branch
  git rebase master             # apply changes from master intelligently into your branch
  git format-patch master       # generate a patch against master
}}}

This will generate a number of patch files, one for each commit in your branch, which you can then submit to the spacewalk-devel mailing list where they can be reviewed and accepted.


=== Applying Patches ===

Applying patches is as simple as:
{{{
  git checkout master              # switch to master so we can update it to the latest
  git pull
  git checkout -b applying-patch   # create a branch to work in
  git am 0001-incoming.patch       # apply the patch in the branch
  (repeat for all .patch files)
  git checkout master       
  git merge applying-patch
  git push
}}}

Note that if you examine the git log, both the git identity of the patch author and the patch committer are tracked.

== Why Use Local Branches ==

The use of local branch has proven one of the more difficult things to adapt to for those coming from non-distributed scm's like subversion. While you can work in your master branch (or another tracking branch), using local branches offers several benefits.

 1. Context Switching: Local branches allow you to work on something, and in the middle either commit or stash your changes and git checkout another local branch to work on something else. This could be a new local branch for some other more urgent task, a release branch for a past version of the product, even a specific commit in the history you need to examine the source tree at. Considering our development setup, this also allows you to switch to run old versions of the application code with a single command.
 1. Safety: Assume you work on some substantial fix, but a major conflict is brewing in master. When merging/rebasing you may get into a situation where you'd just as soon start over. You can easily reset master to point to the state of the remote master branch and begin again, your changes are safely tucked away in your local branch.

== Managing Remote Branches ==

See what remote branches exist:
{{{
git branch -r
}}}

Create a new remote branch (based on an existing local branch):
{{{
git-push origin localbranch:refs/heads/newremotebranch
}}}

Checkout a local copy of a remote branch, originally you will need to track it so you can keep up with changes automatically. (consider this like your local "master" branch, except push/pull works against the remote branch instead of the remote master)
{{{
git checkout --track -b localbranch origin/remotebranch
}}}

Push latest changes from your local branch back to the remote branch: 
{{{

git-push origin localbranch:remotebranch
}}}

If you ever want to use that branch again, you can just do:
{{{
git-checkout my-branchname
}}}

As with any long lived branch it's important to sync it with master periodically to prevent a merge disaster when you rejoin. In the case of long lived branches, use git merge instead of git rebase.
{{{
git checkout master
git pull
git checkout myremotetrackingbranch
git merge master
}}}

Deleting a remote branch entirely: For all intents and purposes lets leave remote branches for the time being. Deleting them can be a little dangerous if you were to happen to do it on a RELEASE branch, and send us digging into scm backups to recover it. Check with someone if you have a temporary remote branch that you really want deleted. Otherwise we'll probably clean them up from time to time.

 * It is a very good idea to treat your tracking branches as you do master. I.e. *do not* work directly in them, but rather create local branches off them to do your work and only use the tracking branch for pulling down changes and then merging in your work and immediately pushing it out.
 * Running "git push" without specifying the branches as per the above syntax will cause git to attempt to push your local commits from all tracked remote branches back to their respective remote counterparts. This is definitely counterintuitive. However if you only use tracking branches for pushing/pulling changes and instead work in local branches, this will not be an issue for you.
 * You will see git pull fetching information about other remote branches, please note this is not applying those commits in your local tracking branch, it's just updating internal info and noticing that something has changed in the remote repo. Only the current branch will have it's changes applied.


== Other Common Tasks ==

Revert a file with uncommitted changes you do not wish to keep:
{{{
  git checkout path/to/file/to/revert.txt
}}}
Revert all your current uncommitted changes:
{{{
  git reset --hard HEAD
}}}
Revert changes from a past commit (generates a new commit):
{{{
  git revert a31f80910768ba2232c796b814be11d064421f19
}}}

View diff of changes in a past commit:
{{{
  git show a31f80910768ba2232c796b814be11d064421f19
}}}

View diff of changes between two past commits:
{{{
  git diff baf1a1490e205f821fbcc9c4ec2581728afd1c14..a31f80910768ba2232c796b814be11d064421f19
}}}

View a part revision of a specific file (feel free to pipe the output somewhere if you like). Make sure to use the full path to the file as it would be from the root of your git repository:
{{{
git show SHA1:java/code/src/com/redhat/rhn/common/db/datasource/xml/Channel_queries.xml
}}}

Replace file with a past version. Note that after doing this you still need to commit the change:
{{{
git checkout SHA1 -- path/to/file
}}}

Once you make changes, you can see the differences you've made since last commit:
{{{
git diff HEAD
}}}

The following commands can help with formatting patches.

{{{
git-format-patch
git-send-email
}}}

Finished with your branch? Want to get rid of it? Then
{{{
git branch -d mybranch
}}}
If you get a warning about unmerged changes, you can force the removal with
{{{
git branch -D mybranch
}}}

See what you have committed but not pushed:

{{{
git log --pretty=oneline origin/master..master
}}}
== Tips ==

 * Install '''tig''' for a very handsome mutt-like command line app for browsing git history and diffs.

 * Install '''gitk''' for a brutally ugly yet still rather useful graphical tool for doing the same thing.

== Building Test RPMs ==

Here is an example workflow where we are working on a spec file and testing with {{{build.py --test --srpm}}}.
For readability we will name different SHA1 number as SHA1-A, SHA1-B, ... You can find build.py in the rel-eng/bin directory of your git checkout, and it can be called relatively or added to your path.

When we begin, the tree has SHA1-A

 {{{$ git commit -a -m 'edit spec to comply with fedora guidelines'}}}

After the commit it now has SHA1-B

 {{{$ gitk --all}}}

Review the changes, then do some testing. You find error,for example, rpmlint complains. Edit the spec.

 {{{$ git commit -a -m 'shut up rpmlint'}}}

The tree now has SHA1-C

 {{{$ build.py --test --srpm}}}

We still find errors, re-edit the spec file.

 {{{$ git commit -a -m 'I hate you rpmlint'}}}

The tree now has SHA1-D
 {{{$ build.py --test --srpm}}}

Again, still more errors, edit the spec file.

 {{{$ git commit -a -m 'say again something rpmlint and I kill you'}}}

The tree now has SHA1-E

 {{{$ build.py --test --srpm}}}

Finally, {{{rpmlint}}} is silent. We will reject all our previous commits,
but they are still in git you may in following steps do in {{{gitk 'Update'}}} to see what happened
do not do 'Reload' as you will not see dead part of tree.
 {{{$ git reset --hard SHA1-A}}}


We now pick up all the previous changes and apply it to our working copy without commits.

 {{{
 $ git cherry-pick -n SHA1-B
 $ git cherry-pick -n SHA1-C
 $ git cherry-pick -n SHA1-D
 $ git cherry-pick -n SHA1-E
 }}}

Now we have one commit including all of the changes:

 {{{$ git commit -a -m 'edit spec to comply with fedora guidelines'}}}

Confirm this is what we wanted and we are ready to merge and push

 {{{$ build.py --test --srpm}}}


== Other Resources ==
 * [http://book.git-scm.com/ Git Community Book]
 * [http://www.kernel.org/pub/software/scm/git/docs/user-manual.html The Git User's Manual]
 * [http://wiki.sourcemage.org/Git_Guide Another awesome Git Guide]
 * [http://www.gitcasts.com/ Git tutorials as screen casts]
 * [http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html Tutorial Introduction to Git]
 * [http://jbowes.dangerouslyinc.com/2007/02/18/git-bisect-a-practical-example-with-yum/ Jbowes' Instructional Blog Post on git-bisect]
 * [http://jbowes.dangerouslyinc.com/2007/01/26/git-rebase-keeping-your-branches-current/ Jbowes' Instructional Blog Post on git-rebase]
 * [http://www.zorched.net/2008/04/14/start-a-new-branch-on-your-remote-git-repository/ - Dealing with remote branches .. ]