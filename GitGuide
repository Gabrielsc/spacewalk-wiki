= [http://git.or.cz/ Git] Guide =

== Getting Started ==
A quick start guide to using git, especially if you're used to using svn or cvs.

=== Install Git ===
First, you'll want to install git.

Fedora users can just install it:
{{{
  yum install git
}}}

RHEL 5 users can get git from EPEL:
{{{
  # add the EPEL repo:
  # see: http://fedoraproject.org/wiki/EPEL/FAQ#howtouse
  rpm -Uvh http://download.fedora.redhat.com/pub/epel/5/i386/epel-release-5-2.noarch.rpm
  yum install git
}}}
=== Clone the Spacewalk git repository ===
For anonymous access to the Spacewalk source code, feel free to clone the repository:
{{{
git clone git://git.fedorahosted.org/git/spacewalk.git/
}}}

Spacewalk [ContibutorList committers] can clone the repository using the ssh url, which is required if you want to push changes into the repo (and of course you need permission to do so).

{{{
git clone ssh://git.fedorahosted.org/git/spacewalk.git/
}}}

For more details check out the DownloadIt page.


=== Identify Yourself ===
A good practice is to identify yourself to git. You can do this by modifying {{{~/.gitconfig}}} so that git knows how to identify your commits. 

'''NOTE:''' git can differentiate between the author of a commit and person with commit access pushing it to the repository. Most of the time these are the same, but in the case of accepting patches from the community the author should be modified (via setting the {{{GIT_AUTHOR_NAME}}} and {{{GIT_AUTHOR_EMAIL}}} environment variables) while keeping your commit user as yourself.

A good sample ~/.gitconfig:

{{{
[user]
    name = Devan Goodwin
    email = dgoodwin@redhat.com

[alias]
    ci = commit -a
    co = checkout
    st = status -a
    praise = blame 

[apply]
    whitespace = strip

[diff]
    color = auto
    rename = copy 

[pager]
    color = true 

[status]
    color = auto
}}}

== Things To Remember ==

 1. '''ALWAYS''' work in branches.
 1. Your git commits are local only until you push them to the remote repository. (or submit a patch if you do not have commit access) 
 1. Use rebase to update your branch before you merge it.
 1. git commands can be run with {{{git-command}}} or {{{git command}}}

== Everyday Workflow ==

Ready to start hacking on the code? Create yourself a branch to work in.
{{{
  git checkout -b bug456789
}}}
This is actually combining two steps into one, you could also do this the long way with:
{{{
  git branch bug456789      # create the branch
  git checkout bug456789    # work on this branch
}}}
List your branches anytime with:
{{{
  git branch                # list all your branches
}}}
You now have a local branch nobody else can see, they're extremely fast and lightweight, and you can commit as you please. Nothing is pushed to the central repository until you explicitly do so.

Note that the single directory you cloned can be used to work on any branch you like with a simple git checkout command. Switching branches is extremely fast and easy and you can do so at virtually any time. Even if you have changes you don't want to commit (which you often can anyhow as you're working in a private branch), you can use git-stash to stash them away and apply them later, possibly to another branch. (if you found yourself working on the wrong branch)

Now that you've branched you can get to work modifying, adding, and deleting files similar to the way you would use svn.

{{{
[gituser@git manager]$ echo "blahblahblah" > newfile
[gituser@git manager]$ git-add newfile
[gituser@git manager]$ git-rm Worker.java 
rm 'java/code/src/com/redhat/rhn/manager/Worker.java'
[gituser@git manager]$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       deleted:    Worker.java
#       new file:   newfile
#
# Changed but not updated:
#   (use "git add <file>..." to update what will be committed)
#
#       modified:   SatManager.java
#
[gituser@git manager]$
}}}

Now it's time to commit (and you can and should commit often, as often as you like). 

'''IMPORTANT NOTE:''' By default, files you have modified will not be included if you run {{{git commit}}}. Normally you will probably just want to use the -a option to commit all modified files:
{{{
  git commit -a
}}}
If you wish to only include '''some''' of the modified files in your commit, you must do something like:
{{{
  git add modified-file1.txt
  git add modified-file3.txt
  git commit
}}}
Repeat for as many commits as you like on your branch until you're satisfied with your bugfix, feature, or whatever.

=== Pushing Changes ===

NOTE: These instructions apply to those with commit access.

When you're ready to push your changes out to the public repository (or submit a patch), we'll use git rebase to apply any changes that have gone on in the remote repository since we branched as seamlessly as possible. If a conflict occurs this is where it will most likely happen, in which case you resolve it and continue the rebase, or start over.
{{{
  git checkout master                 
  git pull                      # fetch latest remote changes into master (should apply clean)
  git checkout bug456789        # return to your branch
  git rebase master             # apply changes from master intelligently into your branch
  git checkout master           # back to master
  git merge bug456789           # merge your changes in (use --squash if you'd like just 1 commit with a new message)
  git push                      # push the changes out to the remote repository
}}}

If you'd prefer to condense this into one command try this bash function:
{{{
function sync-git {
    git checkout master && git pull && git checkout $1 && git rebase master && git checkout master && git merge $1  && echo You are ready to make: git push
}
}}}

=== Submitting Patches ===

For those without commit access, or those who just prefer to submit a patch for review, the steps are as follows:
{{{
  git checkout master                 
  git pull                      # fetch latest remote changes into master (should apply clean)
  git checkout bug456789        # return to your branch
  git rebase master             # apply changes from master intelligently into your branch
  git-format-patch master       # generate a patch against master
}}}

This will generate a number of patch files, one for each commit in your branch, which you can then submit to the spacewalk-devel mailing list where they can be reviewed and accepted.


=== Applying Patches ===

Applying patches is as simple as:
{{{
  git checkout master              # switch to master so we can update it to the latest
  git pull
  git checkout -b applying-patch   # create a branch to work in
  git am 0001-incoming.patch       # apply the patch in the branch
  (repeat for all .patch files)
  git checkout master       
  git merge applying-patch
  git push
}}}

Note that if you examine the git log, the both the git identity of the patch author and the patch committer are tracked.

== Managing Remote Branches ==

See what remote branches exist:
{{{
git branch -r
}}}

Create a new remote branch (based on an existing local branch):
{{{
git-push origin localbranch:refs/heads/newremotebranch
}}}

Checkout a local copy of a remote branch, originally you will need to track it so you can keep up with changes automatically. (consider this like your local "master" branch, except push/pull works against the remote branch instead of the remote master)

{{{
git checkout --track -b my-branchname origin/branchname
}}}

Note that when you have multiple remote branches being tracked, git pull fetches refs for all of them. You may see confusing things on the command line where it appears git is merging in changes into other branches besides the one you are working on. Please note that this is only information relating to the *remote* branch, not your local copy. git is simply noticing that things have changed on the remote side.

However if you attempt a "git push" with no arguments, git will attempt to push *all* tracked remote branches. This is only really an issue if you have been working in one of your branches that tracks a remote branch, made commits that you did not push, then switch to another remote branch and worked there. In this case you may see something on the command line where the other branches (not current one) are rejected. I believe this is quite harmless, the branch you are pushing from should still push successfully, whereas the other will fail gracefully and you can deal with it as you please. However if you wish to avoid the whole issue then:

Push latest changes from your local branch back to the remote branch: (note this avoids the push problem described above)
{{{
git-push origin localbranch:remotebranch
}}}

If you ever want to use that branch again, you can just do:
{{{
git-checkout my-branchname
}}}

As with any long lived branch it's important to sync it with master periodically to prevent a merge disaster when you rejoin. In the case of long lived branches, use git merge instead of git rebase.
{{{
git checkout master
git pull
git checkout myremotetrackingbranch
git merge master
}}}

Deleting a remote branch entirely: (WARNING: be careful with this one)
{{{
git push origin :remotebranchtodelete
}}}



== Other Common Tasks ==

Revert a file with uncommitted changes you do not wish to keep:
{{{
  git checkout path/to/file/to/revert.txt
}}}
Revert all your current uncommitted changes:
{{{
  git reset --hard HEAD
}}}
Revert changes from a past commit with a new commit:
{{{
  git revert a31f80910768ba2232c796b814be11d064421f19
}}}

View diff of changes in a past commit:
{{{
  git diff a31f80910768ba2232c796b814be11d064421f19
}}}
View diff of changes between two past commits:
{{{
  git diff baf1a1490e205f821fbcc9c4ec2581728afd1c14..a31f80910768ba2232c796b814be11d064421f19
}}}

Once you make changes, you can see the differences you've made since last commit:
{{{
git diff HEAD
}}}

The following commands can help with formatting patches.

{{{
git-format-patch
git-send-email
}}}

Finished with your branch? Want to get rid of it? Then
{{{
git branch -d mybranch
}}}
If you get a warning about unmerged changes, you can force the removal with
{{{
git branch -D mybranch
}}}

Working in master when you didn't intend to or got yourself into a mess? Working in branches is always a good idea to offer flexibility should you get into a situation where you get a large master conflict, commit something you don't actually want going to remote master, etc. If you mistakenly do this or get into such a situation you can create a local branch off master at it's current state, and reset master to origin's state. You'll be left with a local branch containing all your work, and a pure master copy you can cherry pick to, merge, whatever.

{{{
git branch mynewlocalbranch
git checkout master
git reset origin/master
}}}

== Tips ==

 * Install '''tig''' for a very handsome mutt-like command line app for browsing git history and diffs.
 * Install '''gitk''' for a brutally ugly yet still rather useful graphical tool for doing the same thing.

== Example workflow of test-srpm ==
Here is an example workflow where we are working on a spec file and testing with {{{make test-srpm}}}.
For readability we will name different SHA1 number as SHA1-A, SHA1-B, ...

When we begin, the tree has SHA1-A

 {{{$ git commit -a -m 'edit spec to comply with fedora guidelines'}}}

After the commit it now has SHA1-B

 {{{$ gitk --all}}}

Review the changes, then do some testing. You find error,for example, rpmlint complains. Edit the spec.

 {{{$ git commit -a -m 'shut up rpmlint'}}}

The tree now has SHA1-C

 {{{$ make test-srpm}}}

We still find errors, re-edit the spec file.

 {{{$ git commit -a -m 'I hate you rpmlint'}}}

The tree now has SHA1-D

 {{{$ make test-srpm}}}

Again, still more errors, edit the spec file.

 {{{$ git commit -a -m 'say again something rpmlint and I kill you'}}}

The tree now has SHA1-E

 {{{$ make test-srpm}}}

Finally, {{{rpmlint}}} is silent. We will reject all our previous commits,
but they are still in git you may in following steps do in {{{gitk 'Update'}}} to see what happened
do not do 'Reload' as you will not see dead part of tree.
 {{{$ git reset --hard SHA1-A}}}


We now pick up all the previous changes and apply it to our working copy without commits.

 {{{
 $ git cherry-pick -n SHA1-B
 $ git cherry-pick -n SHA1-C
 $ git cherry-pick -n SHA1-D
 $ git cherry-pick -n SHA1-E
 }}}

Now we have one commit including all of the changes:

 {{{$ git commit -a -m 'edit spec to comply with fedora guidelines'}}}

Confirm this is what we wanted and we are ready to merge and push

 {{{$ make test-srpm}}}


== Other Resources ==
 * [http://wiki.sourcemage.org/Git_Guide Another awesome Git Guide]
 * [http://www.gitcasts.com/ Git tutorials as screen casts]
 * [http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html Tutorial Introduction to Git]
 * [http://www.kernel.org/pub/software/scm/git/docs/user-manual.html The Git User's Manual]
 * [http://jbowes.dangerouslyinc.com/2007/02/18/git-bisect-a-practical-example-with-yum/ Jbowes' Instructional Blog Post on git-bisect]
 * [http://jbowes.dangerouslyinc.com/2007/01/26/git-rebase-keeping-your-branches-current/ Jbowes' Instructional Blog Post on git-rebase]
 * [http://www.zorched.net/2008/04/14/start-a-new-branch-on-your-remote-git-repository/ - Dealing with remote branches .. ]