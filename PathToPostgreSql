See the [wiki:PathToPostgreSql/Tasks Tasks] page for ongoing progress of this effort.

= Introduction =

Below is a collection of information related to the effort to remove Spacewalk's dependency on Oracle, support PostgreSQL, and ultimately be database agnostic. If you are interested in participating in this effort please feel free to review the projects and tasks below to find something that suits your abilities. If you find something you can assign the task to yourself. Help should be available if you require it on IRC and the mailing list.

All estimates are given in days.

== Architecture We're Striving For ==

 * All database communication done via standardized SQL that will run against the major databases. 
 * Leverage Java Hibernate mappings whenever possible.
 * Migrate all stored procedures to Java application code. (unless absolutely necessary to keep for performance reasons)
 * If stored procedure was used in the Perl stack, migrate the affected pages to Java/JSP.
 * Implement an RPC API for the Python backend to call in place of the stored procedure. (NOTE: unclear if this will be required)

== Development Information ==

Most development of PostgreSQL specific code is underway in the '''postgresql''' branch in git. For information on how to checkout and work with this branch, see the GitGuide.

= Support Intallation of PostgreSQL Schema = 

== Discussion ==

Requires modifications to spacewalk-setup code to isolate any Oracle specific code and fork the execution path based on the selected database backend.

Current plan is to have PostgreSQL schema generated from Oracle schema using a simple type template system.

== Tasks ==

|| Task || Estimate || Assigned To || Status ||
|| Modify spacewalk-setup to support multiple databases || 8 || dgoodwin || ~70% ||
|| Generate PostgreSQL schema from templates || - || paji || done ||

= Port Stored Procedures to Java Application Code =

After examining the advantages/disadvantages of migrating stored procedures straight to Java application code (that will theoretically run on multiple databases) it was decided the alternative (porting PL/SQL to PL/pgSQL and maintaining both versions) would be minimally less expensive (if we require strict unit testing of the new code). Considering that we would ultimately like to be database agnostic, the effort to reach the end goal could double and thus we chose to accept the overhead and proceed to obtain the architecture we want.

See also:
 * [wiki:PathToPostgreSql/StoredProcedureAnalysis StoredProcedureAnalysis]

= Migrate Perl Pages Which Use Stored Procedures =

= Replace Stored Procedure Usage In the Backend =

== Discussion ==

Unclear the RPC layer will be required, or if we could leverage existing XMLRPC API.

[http://developers.facebook.com/thrift/ Thrift] is a library released by the Facebook team under their own open source license. (appears to be suitable for inclusion in Fedora but not yet verified) Thrift has been accepted into the Apache incubator and the proposal can be found [http://wiki.apache.org/incubator/ThriftProposal here]. 

It appears to be a relatively lightweight solution to the problem (as opposed to some of the other alternatives), and extremely fast. Doing some tinkering to see just how fast I wrote a simple do nothing service in Java, and then used a Python client that opened and closed 10,000 consecutive connections. (and ran this twice simultaneously to see how the server dealt) The result from both processes was approximately the same: '''2.80s user 2.39s system 54% cpu 9.499 total'''

It is however poorly documented so initial exploration is a bit hit or miss. In the "postgresql" branch on the git repository you can see some prototype code for this. Some points of interest:

|| spacewalk/thrift/spacewalk.thrift || Service definition used to auto-generate the service code in the various languages. ||
|| java/code/src/com/redhat/rhn/frontend/thrift/SpacewalkService.java || Auto-generated Java service code. ||
|| java/code/src/com/redhat/rhn/frontend/thrift/SpacewalkServiceHandler.java || Our actual implementation of the service. || 
|| spacewalk/java/code/src/com/redhat/rhn/webapp/RhnServletListener.java || Code which starts the RPC service when the webapp comes up. ||

Thrift seems like a relatively good fit for what we wish to accomplish. It appears to have a strong open source future and considering it's use at Facebook, should provide ample performance for what we wish to do.

Concerns or alternative suggestions?
 * ''Will this api layer only contain the stored procs/code equivalent?'' - JesusRodriguez
    * ''It would be great if we could move the entire Java Manager layer into this box, leaving the actions to call api.'' - JesusRodriguez
    * ''I don't see why it couldn't, not something I'd thought of but the RPC layer could easily come into use if we're adding any new code to Perl/Python, or even some kind of more service oriented code.'' - DevanGoodwin
 * ''I'd like to see a diagram of how the flow would work within the current application context. i.e. user hits web page that needs stored proc access or client sends XML-RPC request to python backend.'' - JesusRodriguez




= SQL Standardization =

= Potential Hazards =

 * Custom Data Types -  Spacewalk uses a custom data type EVR_T for rhnPackageEvr table. This EVR_T data type is mainly used for ordering. Look at [http://git.fedorahosted.org/git/spacewalk.git?p=spacewalk.git;a=blob_plain;f=schema/spacewalk/rhnsat/class/evr_t.sql;hb=HEAD evr_t.sql] for the definition of this data type. While Postgres has the facility to create custom data type, it does not have a  'ORDER MEMBER FUNCTION' to dictate natural ordering for the custom data type. Here are some example queries that make use of the order member function in [http://git.fedorahosted.org/git/spacewalk.git?p=spacewalk.git;a=blob_plain;f=java/code/src/com/redhat/rhn/common/db/datasource/xml/Package_queries.xml;hb=HEAD Package_queries.xml]...
{{{
<mode name="system_latest_all_available_packages">
........
   SELECT  p.name_id name_id,
                 p.id,
                 p.evr_id,
                 max(pe.evr) evr,
      from ....
.....
</mode>


<mode name="system_all_available_packages">
........
   SELECT  pn.name AS NAME,....
      from ....
      where ....
...     AND PE2.evr &gt;= full_list.evr)
.....
</mode>
}}}
or [http://git.fedorahosted.org/git/spacewalk.git?p=spacewalk.git;a=blob_plain;f=java/code/src/com/redhat/rhn/common/db/datasource/xml/System_queries.xml;hb=HEAD System_queries.xml]

{{{
<mode name="system_installed_packages">
...
SELECT ...
  FROM ...
 WHERE ...
ORDER BY PN.name, PE.evr
...
</mode>
}}}

To make things a little worse, this EVR_T is used in DB table view definitions that rely on this magical ordering making it difficult to port in application code, for example [http://git.fedorahosted.org/git/spacewalk.git?p=spacewalk.git;a=blob_plain;f=schema/spacewalk/rhnsat/views/rhnChannelNewestPackageView.sql;hb=HEAD rhnChannelNewestPackageView.sql]
{{{
create or replace view
rhnChannelNewestPackageView
as
...
where 
...
and pe.evr = (select	max(sq_pe.evr)
...
}}}
PostgreSQL has a way to create  [http://www.postgresql.org/docs/8.3/interactive/sql-createaggregate.html User defined Aggregate Functions] which has to be explored more and might work well for max, min,and order by have to be worked out... In this case custom methods like evr_max() and evr_min() will have to be created for both oracle and postgres and all the application quesries and view queries have to be replaced with this..

* No Synonyms in Postgres - Basically postgres standard release does not have synonyms. Synonyms are heavily used in the monitoring code.. Some solution has to be worked out..

* No packages or package body in postgres - 80% of our oracle stored procedures are in Package and Package Body. Postgres however does not have the concept of package bodies.. So sql queries with calls like rhn_config_channel.get_user_file_access will have issues.. A fix for this issue might be to define [http://www.postgresql.org/docs/8.3/interactive/ddl-schemas.html Schema]  for each Package name space and define package functions and procedures in the schema .. For example in the case of rhn_config_channel.get_user_file_access, we will have  rhn_config_channel schema and get_user_file_access as a stored procedure in it.. Only issue here is that we will lose ability to store member variables in package body.. But the instances I checked there havent been many packages that have instance variables.


 * There is a certain set of stored procedures within the schema that are referenced from '''within''' the database code directly. An example of this would be this usage of a stored procedure call within a view:

{{{
create or replace view rhnUserChannel as
select	cfp.user_id		user_id,
	cfp.org_id		org_id,
	cfm.channel_id		channel_id,
	'manage'		role
from	rhnChannelFamilyMembers	cfm,
	rhnUserChannelFamilyPerms cfp
where	cfp.channel_family_id = cfm.channel_family_id
	and rhn_channel.user_role_check(cfm.channel_id,
		cfp.user_id, 'manage') = 1
  ...
}}}

These stored procedures can not be extracted out into our RPC layer because they need to be called from within the schema itself.  The above need to be either:

 1.  Ported to PG/SQL
 1.  Inlined into the schema where the procedure is being called from (less desirable, and probably often quite nasty).




== Stats ==
 * Quantitatively speaking we need to port the following components to Postgres.

 || Component || Number || Queried Method ||
 || Tables  || 405 || select count(distinct TABLE_NAME) from ALL_TABLES  where owner='SPACEWALK'; ||
 || VIews  || 60 ||  select count(distinct VIEW_NAME) from ALL_VIEWS  where owner='SPACEWALK'; ||
 || Constraints  || 2675 ||   select count(distinct CONSTRAINT_NAME) from  ALL_CONSTRAINTS where owner='SPACEWALK'; ||
 || Triggers  || 209 || select count(distinct trigger_name) from all_triggers where OWNER='SPACEWALK'; ||
 || Indexes || 776 ||  select count(distinct Index_name) from all_indexes where OWNER='SPACEWALK'; || 
 ||  Procedures and Functions || 38 || See below ||
 || Packages Functions || 90 || See below ||









= Links =

  * [http://www.pgadmin.org/ pgAdmin]: Looks like an exceptional GUI tool for PostgreSQL management.
  * http://www.pgadmin.org/docs/1.4/pg/plpgsql-porting.html: Some notes on migrating Oracle PL/SQL to PL/pgSQL.
  * [http://freshmeat.net/projects/ora2pg/ ora2pg]: Migration tool.
  * http://www.pgcon.org/2008/schedule/attachments/41_oraport.pdf: Porting Oracle Applications to PostgreSQL