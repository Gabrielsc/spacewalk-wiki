
== Telemetry ==

Telemetry is the code name for a simple template-based reporting engine for Spacewalk.  This is '''only''' a prototype at this point and needs a significant amount of work/help to flush out the idea/code. Telemetry uses the xmlrpc scripting [http://www.redhat.com/spacewalk/documentation/api/0.2/ API] to fetch data from Spacewalk servers.  It is written completely in Python, leveraging [http://www.cheetahtemplate.org/ Cheetah] for templating, cron for scheduling, and [http://www.djangoproject.com/ Django] for the webui.

=== Requirements ===

 1. Must be able to leverage Satellite authentication/authorization (user/role).
 2. Must be able to execute reports immediately, or scheduled.
 3. Must be able to group reports logically.
 4. Must be able to generate different formats (.csv, .html, .txt, ...)
 5. Must be able to easily add/modify reports (including report formatting).
 6. Must be able to run reports against multiple satellites, and aggregate data if desired.
 7. Must be able to notify users upon report completion (email).
 8. Must be able to accept report criteria input from user.

=== Architecture Diagram ===
[[Image(telemetry-diagram.jpg)]]

=== Source ===
Telemetry is current located in: /playpen/Telemetry in the spacewalk git repo -> [[https://fedorahosted.org/spacewalk/browser/playpen/Telemetry]]
=== Installation ===

Telemetry is designed to run on any client-system.  It can be run on the Spacewalk server, but not necessarily.

'''Fedora 9'''

 * Django (webui)
 * Cheetah (report templating)
 * PyYAML (report config)

{{{
yum install Django python-cheetah PyYAML
}}}

 * python-crontab

{{{
cd /tmp
wget http://pypi.python.org/packages/any/p/python-crontab/python-crontab-0.7.linux-i686.tar.gz#md5=10ce70d894d6d2b1bffd1a8a339e1ed4
tar -xvzf python-crontab-0.7.linux-i686.tar.gz -C /
}}}


 *Telemetry

{{{
rpm -Uhv http://tsanders.fedorapeople.org/telemetry-0.1-1.noarch.rpm
}}}


=== Sample Reports ===

Telemetry contains a few sample canned reports.  The reports are installed in ''/usr/share/telemetry''.

 * /scripts   -> contains the xmlrpc client reports scripts (these are executable on the cmd-line or via the Telemetry webui.
 * /config    -> contains the report configuration files.
 * /templates -> contains the output format templates.

The report configuration files will '''need''' to be updated with the proper url for your Spacewalk server(s), and report directory.


{{{
cd /usr/share/telemetry/config
vi systemDetails.conf
}}}

{{{
Name: System Details Report
Description: This report provides a list of systems and supporting details (entitlements, channel subscriptions, & system groups.

Report_Script: systemDetailsReport.py

Satellites:
- http://rlx-1-16.rhndev.redhat.com/rpc/api  # Change this to point to the api url for your Spacewalk server(s). #

APIVersions:
- 5.1.0 Java
- 5.1.1 Java

Aggregate: no

Templates:
    txt: SystemDetails.txt

Report_Dir: /home/tsanders/telemetry/reports/
Report_Name: SystemDetails

}}}




=== Config Data Dictionary ===

 Name::
     The name of the Report.

 Description::
     A brief description of the Report.

 Report_Script::
     The .py xmlrpc client script file used to gather report data.  Script needs to be in the ''/usr/share/telemetry/scripts'' directory.

 Satellites::
     The url of the xmlrpc API interface on your Spacewalk server(s).  Multiple servers can be added on separate lines.

 APIVersions::
     The supported versions of the Spacewalk xmlrpc API specification.

 Aggregate::
     A simple boolean value used when specifying multiple Spacewalk servers to indicate whether or not to aggregate the data into a single report.

 Templates::
     The report templates that can be used with this report.  The templates need to be in the ''/usr/share/telemetry/templates'' directory. Currently, the supported types are: txt, csv, & html.

 Report_Dir::
     The directory where the generated reports should be saved.

 Report_Name::
     The name that will be given to the generated reports.  The format will be: Report_Name + datetimestamp + output type (.txt, .csv, .html).
 
 Criteria::
     (''Optional'') User supplied criteria for the generated report. 

 * name: The name of the criterion.
 * label The label of the criterion (used for the webui form field input.)
 * type  The type of the criterion (csv, txt, bool).
 * cols  The number of columns or horizontal size of the text field or text area for webui input.
 * rows  The number of rows or vertical size of the text field or text area for webui input.
 * required Boolean value to specify whether the criterion is optional.

=== Web UI ===

The webui is currently leveraging the simple development webserver that ships with Django.   Todo: Investigate deployment on Apache/mod_python.

'''Starting'''

{{{
telemetry runserver <port>
}}}

'''Browsing'''

Browse to the following URL: http://127.0.0.1:<port> or http://localhost:<port>

=== Screen Shots ===

[[Image(Telemetry-index.jpg)]]

''Telemetry webui - Index Page''

[[Image(Telemetry-reportlist.jpg)]]

''Telemetry webui - Report List''

[[Image(Telemetry-reportdetails.jpg)]]

''Telemetry webui - Report Details'

[[Image(Telemetry-reportresults.jpg)]]

''Telemetry webui - Report Results'



=== Step-by-Step Report Creation Walkthrough ===

'''Note:'''
'''This is a work in progress.....I will remove this comment when it is complete.'''

The plan here is to walkthrough (step-by-step) the creation of a telemetry report.  We will take a simple use case:

Joe is a system administrator and would like to generate a report that lists all of the systems in his organization that have firefox installed, and report back the specific NVREA.

==== Step 1 - Writing the Report Script ====

First, we need to examine the Spacewalk [http://www.redhat.com/spacewalk/documentation/api/0.2/ API] and determine which methods will be used to gather the necessary information.

In our case, we will use the following:

 * system.listUserSystems(string sessionKey)
 * system.listPackages(string sessionKey, int serverId)


The psuedo-code is as follows:

 1. Prompt the user for a csv list of package names (required criteria)
 2. Get all the systems available to the logged-in user.
 3. For each system, get the list of installed packages.
 4. Compare
 5. Report Results (to include name, version, release, epoch, and arch)

We are now ready to open our favorite editor and start coding:

==== systemsByPackageReport.py ====


{{{
#!/usr/bin/env python

import sys
import xmlrpclib
from telemetry import Report
}}}

telemetry.Report is a helper class that handles the xmlrpc connections, template rendering, etc.

{{{
class System():
    pass

class Package():
    pass
}}}

Define data structures to hold our result sets.  In this case we will create and array of System objects, which will contain an array of Package objects.

{{{
# Main Processing
if len(sys.argv) != 6:
    print "Usage %s <config> <type> <username> <password> <packagelist>" % (sys.argv[0])
    sys.exit(1)
}}}

Ensure that *all* 5 required arguments have been supplied to our report script.

{{{
# Arguments
config = sys.argv[1]
type = sys.argv[2]
username = sys.argv[3]
password = sys.argv[4]
packages = sys.argv[5].split(",")
}}}

Define local variables to hold script arguments.

{{{
# Create Report Instance
report = Report(config)

# Get ServerProxies
clients = report.connect()
}}}

Create a report instance, passing the report configuration file, then call the connect method to create !ServerProxy objects for each Spacewalk server defined in the config.

{{{
systems = []
}}}

Define an empty array to hold the system objects that have matching packages installed.

{{{
_count = 0
}}}

Define a variable to keep track of the Spacewalk servers processed.

{{{
for client in clients:
}}}

Iterate over Spacewalk servers.

{{{
    # get the session key
    try:
        key = client.auth.login(username, password)
    except xmlrpclib.Fault, fault:
        print "Error in systemsByPackageReport:"
        print fault.faultCode
        print fault.faultString
}}}

Attempt to login with provided credentials and obtain the session key. 

{{{
    if not (report.parameters['Aggregate']):
        systems = []
}}}
Handle the aggregation parameter as specified in the configuration file.  Essentially this means, create a single report or multiple reports.

{{{
        systems = processData(client,key,systems)
}}}
Call the processData method -> which returns the data structure that will be passed to the template engine.

{{{
        satellites = [report.parameters['Satellites'][_count]]
        vars = {'systems': systems, 'satellites': satellites}
        report.templatify(vars, type)
}}}
Pass the datastructure to the template rendering method of the helper class.

{{{
    else:
        systems = processData(client,key,systems)

    _count = _count + 1

if (report.parameters['Aggregate']):
    vars = {'systems': systems, 'satellites': report.parameters['Satellites']}
    report.templatify(vars, type)
}}}
Next, define the processData method.

{{{
def processData(client, key, systems):

    try:

        user_systems = client.system.listUserSystems(key)

        for system in user_systems:

            print system

            sys_packages = client.system.listPackages(key, system['id'])

                #returns a array of packages installed on the system that are in common with the user provided list
                common_pkgs = comparePkgs(sys_packages, packages)

                if len(common_packages) > 0:
                
                    sys = System()
                    sys.id = system['id']
                    sys.name = system['name']
                    sys.packages = common_pkgs
                    systems.append(sys)

    except xmlrpclib.Fault, fault:
        print "Error in systemByPackageReport.processData():"
        print fault.faultCode
        print fault.faultString

    return systems

}}}

=== Tasks ===

1. Webui

 * style/css
 * navigation/flow
 * notification integration (email)
 * improved scheduling options (one-time-only, daily, weekly, etc)
 * crud functions for report config and templates

2. Infrastructure

 * integration with apache/mod-python
 * store reports on web server
 * single rpm installation with dependendencies

3. Other

 * Handle reporting across orgs (multiple users)

