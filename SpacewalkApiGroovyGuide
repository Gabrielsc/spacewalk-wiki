= The Groovy Coders’ Guide to the Red Hat Network Satellite/Spacewalk API =

== Intended Audience ==

The document is intended for system administrators and/or Groovy coders who wish to make use of the RedHat RHN Satellite v5.1 Server API. There may well be better ways to code the examples below and it should be noted that they have not been thoroughly examined for security issues.

== API Introduction ==

Every Groovy script that accesses the Satellite API must include some variation on the following code:

{{{
import groovy.net.xmlrpc.*

// Set the host appropriately
def host = "satellite.company.com"

def url = "http://${host}/rpc/api"
def client = new XMLRPCServerProxy(url)

// Use the client to obtain the authentication key
def key = client.auth.login(username, password)

assert client != null && key != null  : "Login to RHN Satellite failed!"
}}}

The problem with the above approach is the username and password of a valid (and probably privileged) Satellite user is stored in clear text in each and every one of your scripts. To avoid this, I create the file /etc/satellite_api.conf (which a filemode of 0600 and owned by root:root) which contains:

{{{
satellite.company.com user password
}}}

and use a home grown Groovy class called RHNSession. RHNSession consists of:

{{{
import groovy.net.xmlrpc.*

class RHNSession {

    def configFile = "/etc/satellite_api.conf"

    def client
    def key

    def isLoggedIn() {
        client != null && key != null
    }

    def login() {
        def config = new File(configFile)
        assert config.exists() : "Failed reading ${configFile} because it doesn't exist"

        def (hostname, username, password) = config.readLines()[0].split(" ")

        client = new XMLRPCServerProxy("http://${hostname}/rpc/api")
        key = client.auth.login(username, password)

        assert isLoggedIn() : "Failed logging into ${hostname} as ${username}"
    }

    def logout() {
        assert isLoggedIn() : "Not logged into Satellite"
        assert client.auth.logout(key) == 1 : "Failed logging out of Satellite"
        client = null
        key = null
    }

}
}}}

So your minimal API Groovy script is now:

{{{
RHNSession rhn = new RHNSession()
rhn.login()

rhn.client.api.getApiNamespaces(rhn.key).each { apiNamespace ->
    println apiNamespace
}

rhn.logout()
}}}

=== Complex Example ===

{{{
def releaseChannels = [
    'rhel-i386-es-4':"rhel4-32",
    'rhel-i386-server-5':"rhel5-32",
    'rhel-i386-server-6':"rhel6-32",
    'rhel-x86_64-es-4':"rhel4-64",
    'rhel-x86_64-server-5':"rhel5-64",
    'rhel-x86_64-server-6':"rhel6-64"
]

def now = new Date()
def year = now.format("yyyy")
def month = now.format("MMM").toLowerCase()

releaseChannels.each { original, label ->
    def release = "fy$year-$month-$label"
    println "Working on $release ..."

    // Make sure we're logged in
    assert isLoggedIn() : "Failed logging in, check username and password"

    def orig = rhn.client.channel.software.getDetails(key, original)
    def prev = null

    try {
        prev = rhn.client.channel.software.getDetails(key, release)
    } catch (all) { /* We can ignore this exception; it most likely means channel not found, which is good */ }

    if (prev) {
        // the new release already exists!  it must be deleted... women and children first!
        println " -- Finding child channels for ${prev.label}"
        rhn.client.channel.software.listChildren(key, release).each { child ->
            println "   -- Deleting child channel ${child.label}"
            assert rhn.client.channel.software.delete(key, child.label) == 1 : "Failed deleting ${child.label}"
            Thread.sleep(1000)
        }
        assert rhn.client.channel.software.delete(key, prev.label) == 1 : "Failed removing parent channel ${prev.label}"
        println " -- ${prev.label} successfully deleted"
        Thread.sleep(1000)
    }

    def params = [:]

    if (orig.name) params << [name: "FY $year ${month.toUpperCase()} - ${orig.name}"]
    params << [label: release]
    if (orig.summary) params << [summary: orig.summary]
    if (orig.parent_channel_label) params << [parent_label: release]
    if (orig.gpg_key_url) params << [gpg_url: orig.gpg_key_url]
    if (orig.gpg_key_id) params << [gpg_id: orig.gpg_key_id]
    if (orig.gpg_key_fp) params << [gpg_fingerprint: orig.gpg_key_fp]
    if (orig.description) params << [description: orig.description]

    println " ++ Cloning $original as $release"
    assert rhn.client.channel.software.clone(
            key, original, params, false
        ) > 0 : " ** Failed creating parent channel $release"
    Thread.sleep(1000)

    assert rhn.client.channel.software.setGloballySubscribable(key, release, true) == 1 : "Failed setting ${release} as a globally subscribable channel"
    assert rhn.client.channel.access.setOrgSharing(key, release, "public") == 1 : "Failed setting ${release} as a public channel"
    assert rhn.client.channel.software.regenerateYumCache(key, release) == 1 : "Failed regenerating YUM cache for ${release}"
    Thread.sleep(1000)

    rhn.client.channel.software.listChildren(key, original).each { child ->
        params.clear()

        def childRelease = "fy$year-$month-${child.label}"
        def childName = child.name

        if (child.name) params << [name: "FY $year ${month.toUpperCase()} - ${childName}"]
        params << [label: childRelease]
        if (child.summary) params << [summary: child.summary]
        if (child.parent_channel_label) params << [parent_label: release]
        if (child.gpg_key_url) params << [gpg_url: child.gpg_key_url]
        if (child.gpg_key_id) params << [gpg_id: child.gpg_key_id]
        if (child.gpg_key_fp) params << [gpg_fingerprint: child.gpg_key_fp]
        if (child.description) params << [description: child.description]

        println "   ++ Cloning ${child.label} as child $childRelease"
        assert rhn.client.channel.software.clone(
                key, child.label, params, false
            ) > 0 : "  ** Failed creating child channel $childRelease"
        Thread.sleep(1000)

        assert rhn.client.channel.software.setGloballySubscribable(key, childRelease, true) == 1 : "Failed setting ${childRelease} as a globally subscribable channel"
        assert rhn.client.channel.access.setOrgSharing(key, childRelease, "public") == 1 : "Failed setting ${childRelease} as a public channel"
        assert rhn.client.channel.software.regenerateYumCache(key, childRelease) == 1 : "Failed regenerating YUM cache for ${childRelease}"
        Thread.sleep(1000)
    }

    println "Sleeping 5 seconds before next channel..."
    Thread.sleep(5000)
}
}}}

== API Insights ==


=== Troubleshooting ===

Like Satellite itself, the API is not trivial and can take some time to get your head around. It’s very difficult to understand why your code isn’t working as expected if:

* You can’t visualise the data you are working with
* You don’t know how the module you are using is designed to work.

== Sources ==

* Groovy XMLRPC Module (http://groovy.codehaus.org/XMLRPC)
* RedHat Satellite mailing list (https://www.redhat.com/mailman/listinfo/rhn-satellite-users)
* Documentation on the Satellite Server: (https://satellite.example.com/rhn/apidoc/index.jsp)
